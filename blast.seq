import sys
import math
from random import shuffle

if len(sys.argv) < 3:
  print('expected: <query> <target>')
  sys.exit(1)

type Word = Kmer[11]

MATCH = 5
MISMATCH = -4
T = 13 # score threshold
X = 22 # drop-off threshold (bits)

S = 0.85
PERMUTATIONS = 100

Lambda = 1.33
K = 0.621

def score_bits(s):
  return int((Lambda * s - math.log(K)) / math.log(2.0))

query = seq()
target = seq()

query_words = list[Word]()
target_words = list[Word]()

if sys.argv[1].endswith('.fa'):
  for read in FASTA(sys.argv[1], fai=False) |> seqs:
    query = seq(str(query) + str(read))
    for kmer in read.kmers[Word](1):
      query_words.append(kmer)
else:
  query = seq(sys.argv[1])
  for kmer in query.kmers[Word](1):
    query_words.append(kmer)

for read in FASTA(sys.argv[2], fai=False) |> seqs:
  target = seq(str(target) + str(read))
  for kmer in read.kmers[Word](1):
    target_words.append(kmer)

# Seed
hsp = list[list[int]]()

W = len(query_words[0])

for q, query_word in enumerate(query_words):
  max_score = 0
  target_idx = 0
  for t, target_word in enumerate(target_words):
    score = 0
    for i in range(len(query_word)):
      if query_word[i] == target_word[i]:
        score += MATCH
      else:
        score += MISMATCH

    if max_score < score:
      max_score = score
      target_idx = t
  
  if max_score > T:
    hsp.append([q, target_idx, max_score, W])
  
# Extend
hsp_extended = list[list[int]]()

for h in hsp:
  score = h[2]
  query_idx = h[0]
  target_idx = h[1]
  seg_len = W

  left_offset = 0
  right_offset = W

  while score_bits(h[2]) - score_bits(score) < X:
    left_offset += 1
    right_offset += 1
    
    left_overflow = h[0] - left_offset < 0 or h[1] - left_offset < 0
    right_overflow = h[0] + right_offset > len(query) - 1 or h[1] + right_offset > len(target) - 1

    if left_overflow and right_overflow:
      break

    if not left_overflow:
      query_idx = h[0] - left_offset 
      target_idx = h[1] - left_offset
      seg_len += 1

      if query[query_idx] == target[target_idx]:
        score += MATCH
      else:
        score += MISMATCH
      
    if not right_overflow:
      seg_len += 1

      if query[h[0] + right_offset] == target[h[1] + right_offset]:
        score += MATCH
      else:
        score += MISMATCH

  res = [query_idx, target_idx, score, seg_len]
  if res not in hsp_extended: 
    hsp_extended.append(res)

hsp_cutoff = list[list[int]]()

for h in hsp_extended:
  query_idx = h[0]
  target_idx = h[1]
  score_extend = h[2]
  seg_len = h[3]

  extended_seed = query[query_idx: query_idx + seg_len]
  extended_target = target[target_idx: target_idx + seg_len]
  count_below_extend = 0

  perm = list[seq]()

  for i in extended_seed:
    perm.append(i)

  for i in range(PERMUTATIONS):
    score = 0
    shuffle(perm)

    for i in range(len(perm)):
      if perm[i] == extended_target[i]:
        score += MATCH
      else:
        score += MISMATCH

    if score < score_extend:
      count_below_extend += 1

  if count_below_extend / 100 > S:
    hsp_cutoff.append(h)

hsp_expected = list[list[int]]()

for h in hsp_cutoff:
  score = h[2]
  E = K * len(query) * len(target) * math.pow(math.e, -Lambda * score)

  if E < 10e-20:
    hsp_expected.append(h)

print 'Score: ', sum([score_bits(h[2]) for h in hsp_expected])

